# Authentication

Reflect can authenticate users and authorize access to rooms by calling out to a server you provide.

Here's how it works:

1. Pass some `authToken` to the `Reflect` constructor's `auth` parameter.
2. Specify an `authHandler` in the server's `makeOptions` function that authenticates the user and returns whether they should be allowed in the room.

The signature for the auth handler is as follows:

```ts
/**
 * An `AuthHandler` should validate that the user authenticated by `auth` is
 * authorized to access the room with `roomID`. By 'access' we mean create or
 * connect to the room with `roomID`.
 * @return A promise which resolves to `AuthData` for the user if authentication
 * and authorization is successful. If authentication fails you can return
 * `null`. Exceptions and promise rejections are treated as authentication
 * failures.  The returned `AuthData` is passed via
 * {@link WriteTransaction.auth} to mutators when they are run on the server,
 * and can be used to implement fine-grained server-side authorization of
 * mutations.
 */
export type AuthHandler = (auth: string, roomID: string) => Promise<AuthData>;

/**
 * `AuthData` must include a `userID` which is unique stable identifier
 * for the user.
 * `AuthData` has a size limit of 6 KB.
 * `AuthData` is passed via {@link WriteTransaction.auth} to mutators
 * when they are run on the server, which can use it to supplement
 * mutator args and to authorize the mutation.
 */
export type AuthData = ReadonlyJSONObject & { userID: string };
```

## Implementing `AuthHandler`

The most common implementation is to call an endpoint on your server that validates the `authToken` and returns the `AuthData` for the user. Something like:

```ts
async function fetchAuthHandler(
  auth: string,
  roomID: string
): Promise<AuthData> {
  const response = await fetch(`/reflect-auth?auth=${auth}&roomID=${roomID}`);
  return (await response.json()) as AuthData;
}
```

However, you can also use <a href="https://jwt.io/">JWTs</a> or similar to implement auth. In that case, the `auth` string would be a JWT which would be verified in the `AuthHandler`:

```ts
async function jwtAuthHandler(auth: string, roomID: string): Promise<AuthData> {
  const decoded = await jwt.verify(auth, publicKey);
  return decoded as AuthData;
}
```

## Fine-Grained Authorization

Returning `{userID: $userID}` from the `AuthHandler` authorizes the connecting user to access the room.

It is also possible to control whether each individual mutation is allowed. To do so, return additional data as part of the `AuthData` object. This data will be passed to mutators via the `WriteTransaction.auth` parameter. You can then use this data to decide whether to allow the mutation:

```ts
type MyAuthData = AuthData & { access: "read" | "write" };

async function detailedAuthHandler(
  auth: string,
  roomID: string
): Promise<MyAuthData> {
  const response = await fetch(`/reflect-auth?auth=${auth}&roomID=${roomID}`);
  return (await response.json()) as MyAuthData;
}
```

Then, in a mutator:

```ts
const mutators = {
  editNodeContent: async (tx: WriteTransaction,
      {nodeID, content}: {nodeID: string, content: string}) {
    const node = await getNode(tx, nodeID);
    const auth = tx.auth as MyAuthData;
    if (auth === undefined || // auth is always undefined on client
        auth.access === 'write') {
      // Allow the mutation
    } else {
      console.error("Access denied");
    }
  }
}
```

Instead of simply skipping an unauthorized mutation, you can also perform different logic, for example making some similar change which is allowed.

Because Reflect is server-authoritative, optimistic mutations are always rolled back and replaced by authoritative results.

<div className="showFooter"></div>
